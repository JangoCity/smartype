package com.mparticle.smartype.generator

import com.mparticle.smartype.api.Message
import com.mparticle.smartype.api.MessageReceiver
import com.mparticle.smartype.api.SmartypeApiBase
import com.squareup.kotlinpoet.*
import kotlinx.serialization.json.*
import java.io.File
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import kotlinx.serialization.ContextualSerialization
import kotlinx.serialization.modules.SerialModule
import kotlin.collections.MutableList

class SmartypeObject() {
    companion object {
        /**
         * Smartype will use this to name [Message] objects, each [AnalyticsSchemaAdapter]
         * should fill this in based on what it knows about the schema.
         */
        const val SMARTYPE_OBJECT_NAME = "smartype_object_name"
    }
    private var dpClass: TypeSpec.Builder
    private var file: FileSpec.Builder
    private var libraryName: String = "SmartypeApi"

    init {
        dpClass = TypeSpec.classBuilder(libraryName)
            .superclass(SmartypeApiBase::class)
            .primaryConstructor(
                FunSpec.constructorBuilder()
                .build())
        file = FileSpec.builder("com.mparticle.smartype", libraryName)
            .addComment("CODE GENERATED BY SMARTYPE, DO NOT MODIFY.")
        file.addImport("kotlinx.serialization.modules", "SerializersModule")
        file.addImport("com.mparticle.smartype.api", "Message")
    }

    fun finalize(outputDirectory: String) {
        file.addType(dpClass.build())
        file.build().writeTo(File(outputDirectory))
    }

    fun configureApi(
        schema: AnalyticsSchema
    ) {
        println("Creating API with ${schema.smartypeMessageSchemas.size} message schema(s).")
        dpClass.addSuperclassConstructorParameter("%L", "receivers")
        dpClass.addProperties(schema.smartypeApiPublicProperties)
        dpClass.primaryConstructor(
            FunSpec.constructorBuilder()
                .addParameter(ParameterSpec.builder("receivers",
                    MutableList::class.parameterizedBy(MessageReceiver::class)).build())
                .build()
        )

        val funSpec = FunSpec.builder("getSerialModule")
            .addCode("return SerializersModule {\n")
            .addCode("  polymorphic(Message::class) {\n")

        val classPoints = mutableListOf<TypeSpec>()
        for (messageSchema in schema.smartypeMessageSchemas) {
            val name = getObjectName(messageSchema) ?: continue
            val sanitizedName = StringHelpers.sanitize(name)
            val classPoint = generateType(sanitizedName, messageSchema, true)
            classPoints.add(classPoint)
        }
        addClassFunctions(dpClass, classPoints)
        addClassSerializers(funSpec, classPoints)
        dpClass.addFunction(funSpec.addCode("  }\n}\n")
            .addModifiers(KModifier.OVERRIDE)
            .returns(SerialModule::class)
            .build()
        )
    }

    private fun addClassFunctions(dpClass: TypeSpec.Builder, classPoints: Collection<TypeSpec>){
        classPoints.forEach { point ->
            var builder = FunSpec.builder(point.name!!.decapitalize())
                .returns(ClassName("com.mparticle.smartype", point.name!!))

            if (point.primaryConstructor != null &&
                !point.primaryConstructor?.parameters.isNullOrEmpty()
                ) {
                builder.addParameters(point.primaryConstructor?.parameters!!)
                val parameterNameList = point.primaryConstructor?.parameters!!.map { it.name }.toTypedArray()
                val parameterList = point.primaryConstructor?.parameters!!.map { "%L" }
                    .joinToString(",")
                builder.addCode("    return %L(${parameterList})", point.name!!, *parameterNameList)
            } else {
                builder.addCode("    return %L()", point.name!!)
            }

            dpClass.addFunction(
                builder.build()
            )
        }
    }

    private fun addClassSerializers(funSpec: FunSpec.Builder, classPoints: Collection<TypeSpec>){
        classPoints.forEach { point ->
            funSpec.addCode("    %L::class with %L.serializer()\n", point.name, point.name)
        }
    }

    private fun getObjectName(schema: JsonObject): String? {
        val name = schema[SMARTYPE_OBJECT_NAME]?.content
        if (name != null) {
            println("Found name: $name")
        } else {
            println("Unable to find name for schema: $schema")
        }
        return name
    }

    private fun packageClass(name: String) =
        ClassName("com.mparticle.smartype", name)

    private fun generateType(
        classNamePoint: String,
        definition: JsonObject,
        isLoggable: Boolean
    ):TypeSpec {
        val dpClassPoint = TypeSpec.classBuilder(classNamePoint)
        dpClassPoint.addAnnotation(
            AnnotationSpec.builder(
                    ClassName("kotlinx.serialization", "Serializable"))
                .build()
        )


        val ctor = FunSpec.constructorBuilder()
        if (isLoggable) {
            dpClassPoint.superclass(Message::class)
        }

        val schemaDescription: JsonLiteral?
        if (definition.containsKey("description")) {
            schemaDescription = definition["description"] as JsonLiteral
            if (!schemaDescription.content.isBlank()) {
                dpClassPoint.addKdoc(schemaDescription.content)
            }
        }

        dpClassPoint.primaryConstructor(
            FunSpec.constructorBuilder()
                .build()
        )

        val required = mutableListOf<JsonElement>()
        if (definition.contains("required")) {
            required.addAll(definition.getArray("required").toMutableList())
        }
        if (definition.contains("properties")) {
            val properties = definition.getObject("properties")
            for (name in properties.keys) {
                val info = properties[name] as JsonObject
                val sanitizedName = StringHelpers.sanitize(name)
                val sanitizedLower = StringHelpers.lowerFirst(sanitizedName)

                var isRequired = requiredCheck(required, name)
                var valueConst: JsonElement? = null
                if (info.contains("const")) {
                    valueConst = info["const"]
                    isRequired = true
                }

                var type: JsonLiteral?
                if (info.containsKey("type")) {
                    type = info["type"] as JsonLiteral
                } else {
                    type = JsonLiteral("string")
                }

                var description: JsonLiteral? = null
                if (info.containsKey("description")) {
                    description = info["description"] as JsonLiteral
                }

                if (JsonLiteral(string = "string") == type) {
                    val enum = info["enum"] as? JsonArray
                    if (enum != null) {
                        val enumName = "$classNamePoint$sanitizedName"
                        addEnum(enumName, enum, file)
                        val typeName: TypeName = packageClass(enumName)
                        addProperty(isRequired, typeName, sanitizedLower, dpClassPoint, valueConst, description, name, ctor)
                    } else {
                        val typeName: TypeName = String::class.asTypeName()
                        addProperty(isRequired, typeName, sanitizedLower, dpClassPoint, valueConst, description, name, ctor)
                    }
                } else if (JsonLiteral(string = "number") == type) {
                    val typeName: TypeName = Double::class.asTypeName()
                    addProperty(isRequired, typeName, sanitizedLower, dpClassPoint, valueConst, description, name, ctor)
                } else if (JsonLiteral(string = "boolean") == type) {
                    val typeName: TypeName = Boolean::class.asTypeName()
                    addProperty(isRequired, typeName, sanitizedLower, dpClassPoint, valueConst, description, name, ctor)
                } else if (JsonLiteral(string = "object") == type) {
                    val classNameObject = "$classNamePoint$sanitizedName"
                    val typeName = packageClass(classNameObject)
                    addProperty(isRequired, typeName, sanitizedLower, dpClassPoint, null, description, name, ctor)
                    generateType(
                        classNameObject,
                        info,
                        false
                    )
                } else if (JsonLiteral("array") == type) {
                    val typeName = MutableList::class.asClassName().parameterizedBy(String::class.asClassName())
                    addProperty(isRequired, typeName, sanitizedLower, dpClassPoint, null, description, name, ctor)
                }
            }
        }
        if (!ctor.parameters.isNullOrEmpty()) {
            dpClassPoint.addModifiers(KModifier.DATA)
            dpClassPoint.primaryConstructor(ctor.build())
        }

        val classPoint = dpClassPoint.build()
        file.addType(classPoint)
        return classPoint
    }

    private fun addEnum(
        enumName: String,
        enum: JsonArray,
        file: FileSpec.Builder
    ) {
        val builder = TypeSpec.enumBuilder(enumName)
        builder.addAnnotation(AnnotationSpec.builder(ClassName("kotlinx.serialization", "Serializable")).build())

        for (value in enum) {
            val origStr = value.content
            val str = origStr.toUpperCase()
            val annotation = AnnotationSpec.builder(ClassName("kotlinx.serialization", "SerialName")).addMember("\"$origStr\"").build()
            builder.addEnumConstant(str, TypeSpec.anonymousClassBuilder().addAnnotation(annotation).build())
        }

        val enumType = builder.build()
        file.addType(enumType)
    }

    private fun requiredCheck(required: MutableList<JsonElement>?, name: String): Boolean {
        var isRequired = false
        if (required != null) {
            for (requiredName in required) {
                if (JsonLiteral(string = name) == requiredName) {
                    isRequired = true
                }
            }
        }
        return isRequired
    }

    private fun addProperty(
        isRequired: Boolean,
        typeName: TypeName,
        sanitizedLower: String,
        dpClassPoint: TypeSpec.Builder,
        valueConst: JsonElement?,
        description: JsonLiteral?,
        serialName: String,
        ctor: FunSpec.Builder
    ) {
        var mutableTypeName = typeName
        if (valueConst == null && !isRequired) {
            mutableTypeName = mutableTypeName.copy(nullable = true)
        }
        val propertyBuilder = PropertySpec.builder(sanitizedLower, mutableTypeName)
        if (valueConst == null) {
            propertyBuilder.mutable(true)
            propertyBuilder.initializer(sanitizedLower)
            ctor.addParameter(sanitizedLower, mutableTypeName)
        } else {
            val literalValue = valueConst as? JsonLiteral
            val primitiveValue = valueConst as? JsonPrimitive
            if (literalValue != null) {
                propertyBuilder.initializer(valueConst.toString())
            } else if (primitiveValue != null) {
                propertyBuilder.initializer("%L", primitiveValue.double)
            }

        }

        propertyBuilder.addModifiers(KModifier.PUBLIC)

        if (description != null && !description.content.isBlank()) {
            propertyBuilder.addKdoc(description.content)
        }
        propertyBuilder.addAnnotation(
            AnnotationSpec.builder(ClassName("kotlinx.serialization", "SerialName")).addMember("\"$serialName\"")
                .build()
        )
        if (typeName == Number::class.asClassName()) {
            propertyBuilder.addAnnotation(ContextualSerialization::class)
        }
        dpClassPoint.addProperty(
            propertyBuilder.build()
        )
    }
}
